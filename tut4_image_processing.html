<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CARLsim: Tutorial 4: Image Processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="CARLsimStyles.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CARLsim
   &#160;<span id="projectnumber">4.1.0</span>
   </div>
   <div id="projectbrief">CARLsim: a GPU-accelerated SNN simulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tut4_image_processing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial 4: Image Processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut4s1_visual_stimulus">4.1 VisualStimulusToolbox</a><ul><li class="level2"><a href="#tut4s1s1_installing_vst">4.1.1 Installing VisualStimulusToolbox</a></li>
<li class="level2"><a href="#tut4s1s2_first_steps">4.1.2 First Steps</a></li>
<li class="level2"><a href="#tut4s1s2_converting">4.1.3 Converting an Image</a></li>
</ul>
</li>
<li class="level1"><a href="#tut4s2_gaussian_blur">4.2 Gaussian Blur</a><ul><li class="level2"><a href="#tut4s2s1_importing">4.2.1 Importing the Image</a></li>
<li class="level2"><a href="#tut4s2s2_assigning">4.2.2 Assigning Image Pixels to Neurons</a></li>
<li class="level2"><a href="#tut4s2s3_smoothing">4.2.3 Performing the Smoothing</a></li>
<li class="level2"><a href="#tut4s2s4_plotting">4.2.4 Visualizing the Output</a></li>
</ul>
</li>
<li class="level1"><a href="#tut4s3_dog">4.3 Difference of Gaussians: Edge Detection</a><ul><li class="level2"><a href="#tut4s3s1_setup">4.3.1 Setting up the Network</a></li>
<li class="level2"><a href="#tut4s3s2_dog">4.3.2 Performing the Difference of Gaussians (DOG) Operation</a></li>
<li class="level2"><a href="#tut4s3s3_converting">4.3.3 Converting Pixels to Spikes</a></li>
<li class="level2"><a href="#tut4s3s4">4.3.4 Running the Network</a></li>
<li class="level2"><a href="#tut4s3s5_plotting">4.3.5 Visualizing the Output</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Michael Beyeler </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ch1_getting_started.html">Chapter 1: Getting Started</a> </dd>
<dd>
<a class="el" href="ch2_basic_concepts.html">Chapter 2: Basic Concepts</a> </dd>
<dd>
<a class="el" href="ch3_neurons_synapses_groups.html">Chapter 3: Neurons, Synapses, and Groups</a> </dd>
<dd>
<a class="el" href="ch4_connections.html">Chapter 4: Connections</a> </dd>
<dd>
<a class="el" href="ch9_matlab_oat.html">Chapter 9: MATLAB Offline Analysis Toolbox (OAT)</a></dd></dl>
<p>In this tutorial, we will take a closer look at <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a>'s spatial connectivity profiles by implementing a simple image filter. Specifically, we will use the Gaussian connectivity profile to implement a smoothening operation and an edge detector (using a difference of Gaussians). To make this work, we will make use of both the Offline Analysis Toolbox and the Visual Stimulus Toolbox.</p>
<p>At the end of the tutorial, you will know how to:</p><ul>
<li>implement Gaussian connectivity profiles</li>
<li>use the <a class="el" href="structGrid3D.html" title="A struct to arrange neurons on a 3D grid (a primitive cubic Bravais lattice with cubic side length 1)">Grid3D</a> and <a class="el" href="structRadiusRF.html" title="A struct to specify the receptive field (RF) radius in 3 dimensions.">RadiusRF</a> structs for 2-D and 3-D transforms</li>
<li>import stimuli from the VisualStimulusToolbox into <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a></li>
<li>set up a custom <a class="el" href="classSpikeGenerator.html">SpikeGenerator</a> object</li>
<li>create Gaussian connections for neurons arranged on a 2D/3D grid</li>
</ul>
<p>The source code of this tutorial can be found in <code>%%CARLSIM_ROOT_DIR%%/doc/source/tutorial/4_image_processing</code>.</p>
<h1><a class="anchor" id="tut4s1_visual_stimulus"></a>
4.1 VisualStimulusToolbox</h1>
<p><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> uses VisualStimulusToolbox in MATLAB to convert images into binary files that <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> can understand.</p>
<p>VisualStimulusToolbox is a lightweight MATLAB toolbox for generating, storing, and plotting 2D visual stimuli commonly used in vision and neuroscience research, such as sinusoidal gratings, plaids, random dot fields, and noise. Every stimulus can be plotted, recorded to AVI, and stored to binary:</p>
<p><img src="https://camo.githubusercontent.com/35212d317105107855aaa4f5dc2bbb306edf343a/687474703a2f2f7563692d6361726c2e6769746875622e696f2f56697375616c5374696d756c7573546f6f6c626f782f696d672f76697375616c7374696d756c75732e6a7067" alt="" style="width: 40%" class="inline"/></p>
<h2><a class="anchor" id="tut4s1s1_installing_vst"></a>
4.1.1 Installing VisualStimulusToolbox</h2>
<p>VisualStimulusToolbox is available on <a href="https://github.com/UCI-CARL/VisualStimulusToolbox">GitHub</a>, but <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> comes pre-installed with an appropriate version of it (see <code>external/VisualStimulusToolbox</code>).</p>
<p>If you followed the <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> installation instructions outlined in <a class="el" href="ch1_getting_started.html">Chapter 1: Getting Started</a>, you are already good to go!</p>
<p>However, if your <code>external/VisualStimulusToolbox</code> directory is empty (e.g., because you forgot the <code>&ndash;recursive</code> flag when you cloned <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a>), you have to initialize the submodule yourself. Simply navigate to the <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> root directory and run the following:</p>
<div class="fragment"><div class="line">$ git submodule update --init --recursive</div>
</div><!-- fragment --><p>The scripts below will automatically add the toolbox to your MATLAB path. Alternatively, you can install the toolbox as an add-on (MATLAB R2016a and newer): To open the Add-On Manager, go to the <code>Home</code> tab, and select <code>Add-Ons &gt; Manage Add-Ons</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://uci-carl.github.io/VisualStimulusToolbox">http://uci-carl.github.io/VisualStimulusToolbox</a></dd></dl>
<h2><a class="anchor" id="tut4s1s2_first_steps"></a>
4.1.2 First Steps</h2>
<p>To make sure VisualStimulusToolbox has been installed correctly, try opening an image file. In MATLAB, navigate to the <code>input</code> directory of this tutorial, then type:</p>
<div class="fragment"><div class="line">&gt;&gt; pic = PictureStim(<span class="stringliteral">&#39;carl.jpg&#39;</span>)</div>
<div class="line"> </div>
<div class="line">pic = </div>
<div class="line"> </div>
<div class="line">  PictureStim with properties:</div>
<div class="line"> </div>
<div class="line">                  width: 2182</div>
<div class="line">                 height: 2255</div>
<div class="line">               channels: 1</div>
<div class="line">                 length: 1</div>
<div class="line">                   stim: [2255x2182 <span class="keywordtype">double</span>]</div>
<div class="line">    supportedNoiseTypes: {<span class="stringliteral">&#39;gaussian&#39;</span>  <span class="stringliteral">&#39;localvar&#39;</span>  <span class="stringliteral">&#39;poisson&#39;</span>  <span class="stringliteral">&#39;salt &amp; pepper&#39;</span>  <span class="stringliteral">&#39;speckle&#39;</span>}</div>
</div><!-- fragment --><p>You can then have a look at the picture you just loaded by typing:</p>
<div class="fragment"><div class="line">&gt;&gt; pic.plot()</div>
</div><!-- fragment --><div class="image">
<img src="4_carl_raw.jpg" alt=""/>
<div class="caption">
CARL logo</div></div>
<h2><a class="anchor" id="tut4s1s2_converting"></a>
4.1.3 Converting an Image</h2>
<p>In order to convert an image, you can use the script <code>createStimFromImage.m</code> located in the <code>scripts</code> folder of this tutorial.</p>
<p>The script is executed as follows:</p>
<div class="fragment"><div class="line">&gt;&gt; createStimFromImage(<span class="stringliteral">&#39;../input/carl.jpg&#39;</span>, <span class="stringliteral">&#39;../input/carl.dat&#39;</span>, [256 256], <span class="stringliteral">&#39;gray&#39;</span>)</div>
</div><!-- fragment --><p>This will resize the grayscale image <code>../input/carl.jpg</code> to 256x256 pixels and store the image in a binary format that <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> can understand (<code>../input/carl.dat</code>).</p>
<h1><a class="anchor" id="tut4s2_gaussian_blur"></a>
4.2 Gaussian Blur</h1>
<p>The first image processing technique we will look at is Gaussian smoothening. This technique is implemented in <code>main_smooth.cpp</code>.</p>
<h2><a class="anchor" id="tut4s2s1_importing"></a>
4.2.1 Importing the Image</h2>
<p>The idea is to assign every pixel in the image to a neuron in the spiking network. In order to preserve spatial relationships, we arrange all neurons in a grid that matches the image dimensions. The image is simply imported by: </p><div class="fragment"><div class="line"><a class="code" href="classVisualStimulus.html">VisualStimulus</a> stim(<span class="stringliteral">&quot;input/carl.dat&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="tut4s2s2_assigning"></a>
4.2.2 Assigning Image Pixels to Neurons</h2>
<p>We can create a <a class="el" href="structGrid3D.html" title="A struct to arrange neurons on a 3D grid (a primitive cubic Bravais lattice with cubic side length 1)">Grid3D</a> struct from the <code>stim</code> dimensions: </p><div class="fragment"><div class="line"><a class="code" href="structGrid3D.html">Grid3D</a> imgDim(stim.getWidth(), stim.getHeight(), stim.getChannels());</div>
</div><!-- fragment --><p>We also want a grid for the downscaled, blurred version of the image: </p><div class="fragment"><div class="line"><a class="code" href="structGrid3D.html">Grid3D</a> imgSmallDim(imgDim.width/2, imgDim.height/2, 1);</div>
</div><!-- fragment --><p>So all we need to do is create groups with the above grids:</p>
<div class="fragment"><div class="line"><span class="comment">// ---------------- CONFIG STATE -------------------</span></div>
<div class="line"><a class="code" href="classCARLsim.html">CARLsim</a> sim(<span class="stringliteral">&quot;smooth&quot;</span>, <a class="code" href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258a0b5ee5e90bb225a562d92e4078ad9728">GPU_MODE</a>, <a class="code" href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54ae2d30a195cee6b2961cc2c23ea4b520b">USER</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> gIn = sim.<a class="code" href="classCARLsim.html#a0bf4d12b0b90740faf9a2f6a4add0351">createSpikeGeneratorGroup</a>(<span class="stringliteral">&quot;input&quot;</span>, imgDim, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>);</div>
<div class="line"><span class="keywordtype">int</span> gSmooth = sim.<a class="code" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">createGroup</a>(<span class="stringliteral">&quot;smooth&quot;</span>, imgSmallDim, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>);</div>
<div class="line">sim.<a class="code" href="classCARLsim.html#aa6e1dc5ae50722ae3d693f2c963d84cd">setNeuronParameters</a>(gSmooth, 0.02f, 0.2f, -65.0f, 8.0f);</div>
</div><!-- fragment --><h2><a class="anchor" id="tut4s2s3_smoothing"></a>
4.2.3 Performing the Smoothing</h2>
<p>The Gaussian blur is simply implemented by a Gaussian connection. The trick is to use the <a class="el" href="structRadiusRF.html" title="A struct to specify the receptive field (RF) radius in 3 dimensions.">RadiusRF</a> struct to define the Gaussian kernel. For image processing, we want a Gaussian kernel in x and y dimensions, such as a 5x5 kernel. This is equivalent to ::RadiusRF(5, 5, 0). Here, the zero specifies that the smoothing will be performed separately for every channel (third dimension). If we wanted to smooth over the third dimension (e.g., a Gaussian voxel), we would choose ::RadiusRF(5, 5, 5).</p>
<p>However, what we really want is to sum or average over all three color channels if the image is RGB. We do this by specifying <a class="el" href="structRadiusRF.html" title="A struct to specify the receptive field (RF) radius in 3 dimensions.">RadiusRF</a>(5, 5, -1): </p><div class="fragment"><div class="line">sim.<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(gIn, gSmooth, <span class="stringliteral">&quot;gaussian&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(2.0f), 1.0f,</div>
<div class="line">    <a class="code" href="structRangeDelay.html">RangeDelay</a>(1), <a class="code" href="structRadiusRF.html">RadiusRF</a>(5,5,-1));</div>
</div><!-- fragment --><p>We set up some <a class="el" href="classSpikeMonitor.html" title="Class SpikeMonitor.">SpikeMonitor</a> objects so that we can have a look at the output: </p><div class="fragment"><div class="line"><span class="comment">// ---------------- SETUP STATE -------------------</span></div>
<div class="line">sim.<a class="code" href="classCARLsim.html#a6d6c298c788eeb7b18a19d82a77761b3">setupNetwork</a>();</div>
<div class="line"> </div>
<div class="line">sim.<a class="code" href="classCARLsim.html#a1e0b4d170b65f5075f1a996554c842ab">setSpikeMonitor</a>(gIn, <span class="stringliteral">&quot;DEFAULT&quot;</span>);</div>
<div class="line">sim.<a class="code" href="classCARLsim.html#a1e0b4d170b65f5075f1a996554c842ab">setSpikeMonitor</a>(gSmooth, <span class="stringliteral">&quot;DEFAULT&quot;</span>);</div>
</div><!-- fragment --><p>We then read the pixels of the image using the <a class="el" href="classVisualStimulus.html" title="Class to integrate CARLsim with a stimulus created using VisualStimulus.m Version: 4/11/14 Author: Mi...">VisualStimulus</a> bindings: </p><div class="fragment"><div class="line"><a class="code" href="classPoissonRate.html">PoissonRate</a>* rates = stim.readFramePoisson(50.0f, 0.0f);</div>
</div><!-- fragment --><p> This reads all pixel values and normalizes them in the range [0, 50Hz], such that white pixels (grayscale value 255) is assigned to 50 Hz, and 0 is 0.</p>
<p>The <a class="el" href="classPoissonRate.html" title="Class for generating Poisson spike trains.">PoissonRate</a> object that is returned from this call neatly fits into <a class="el" href="classCARLsim.html#a04f52d2840105c8ccacf8d378d1695cf" title="Sets a spike rate.">CARLsim::setSpikeRate</a>: </p><div class="fragment"><div class="line">sim.<a class="code" href="classCARLsim.html#a04f52d2840105c8ccacf8d378d1695cf">setSpikeRate</a>(gIn, rates);</div>
</div><!-- fragment --><p>Then all that is left to do is run the network: </p><div class="fragment"><div class="line">sim.<a class="code" href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">runNetwork</a>(1,0); <span class="comment">// run the network</span></div>
</div><!-- fragment --><p>This works for movies as well (where the number of frames &gt; 1). For this, we simply wrap the above commands in a for loop, and repeated calls to <code>readFrame</code> will simply process the next frame in the loop: </p><div class="fragment"><div class="line"><span class="comment">// ---------------- RUN STATE -------------------</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;stim.getLength(); i++) {</div>
<div class="line">    <a class="code" href="classPoissonRate.html">PoissonRate</a>* rates = stim.readFramePoisson(50.0f, 0.0f);</div>
<div class="line">    sim.<a class="code" href="classCARLsim.html#a04f52d2840105c8ccacf8d378d1695cf">setSpikeRate</a>(gIn, rates);</div>
<div class="line">    sim.<a class="code" href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">runNetwork</a>(1,0); <span class="comment">// run the network</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>And done!</p>
<h2><a class="anchor" id="tut4s2s4_plotting"></a>
4.2.4 Visualizing the Output</h2>
<p>You can compile and run the above network as follows:</p>
<div class="fragment"><div class="line">$ make smooth</div>
<div class="line">$ ./smooth</div>
</div><!-- fragment --><p>The result can then be analyzed using the OAT. Visualizing network activity is easiest with the NetworkMonitor. Go back to the <code>scripts</code> folder in MATLAB, and run:</p>
<div class="fragment"><div class="line">&gt;&gt; demoSmooth</div>
</div><!-- fragment --><div class="image">
<img src="4_carl_smooth.jpg" alt=""/>
<div class="caption">
Gaussian smoothing using CARLsim</div></div>
<h1><a class="anchor" id="tut4s3_dog"></a>
4.3 Difference of Gaussians: Edge Detection</h1>
<p>We can extend the above example by implementing an edge detector using a difference of Gaussians (DOG) operation. For this, we will first convolve the image with a small Gaussian kernel <a class="el" href="structRadiusRF.html" title="A struct to specify the receptive field (RF) radius in 3 dimensions.">RadiusRF</a>(0.5, 0.5, -1), which is basically a "one-to-one" connection. From the output of this operation, we will then subtract a blurred version of the image. The result will be an edge map.</p>
<h2><a class="anchor" id="tut4s3s1_setup"></a>
4.3.1 Setting up the Network</h2>
<p>Importing the image and setting up the <a class="el" href="structGrid3D.html" title="A struct to arrange neurons on a 3D grid (a primitive cubic Bravais lattice with cubic side length 1)">Grid3D</a> structs is the same as above:</p>
<div class="fragment"><div class="line"><a class="code" href="classCARLsim.html">CARLsim</a> sim(<span class="stringliteral">&quot;dog&quot;</span>, <a class="code" href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258a0b5ee5e90bb225a562d92e4078ad9728">GPU_MODE</a>, <a class="code" href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54ae2d30a195cee6b2961cc2c23ea4b520b">USER</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classVisualStimulus.html">VisualStimulus</a> stim(<span class="stringliteral">&quot;input/carl.dat&quot;</span>);</div>
<div class="line">stim.print();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structGrid3D.html">Grid3D</a> imgDim(stim.getWidth(), stim.getHeight(), stim.getChannels());</div>
<div class="line"><a class="code" href="structGrid3D.html">Grid3D</a> imgSmallDim(imgDim.width/2, imgDim.height/2, 1);</div>
</div><!-- fragment --><p>From these specs, we will create the input and smoothing groups as above: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> gIn = sim.<a class="code" href="classCARLsim.html#a0bf4d12b0b90740faf9a2f6a4add0351">createSpikeGeneratorGroup</a>(<span class="stringliteral">&quot;input&quot;</span>, imgDim, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>);</div>
<div class="line"><span class="keywordtype">int</span> gSmoothExc = sim.<a class="code" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">createGroup</a>(<span class="stringliteral">&quot;smoothExc&quot;</span>, imgSmallDim, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>);</div>
<div class="line">sim.<a class="code" href="classCARLsim.html#aa6e1dc5ae50722ae3d693f2c963d84cd">setNeuronParameters</a>(gSmoothExc, 0.02f, 0.2f, -65.0f, 8.0f);</div>
</div><!-- fragment --><p>However, this time around we also need an inhibitory group, so that we can subtract the blurred version of the image, and an output group that will contain the edge map: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> gSmoothInh = sim.<a class="code" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">createGroup</a>(<span class="stringliteral">&quot;smoothInh&quot;</span>, imgSmallDim, <a class="code" href="carlsim__definitions_8h.html#a1f1973192224715d2362de045a5c6387">INHIBITORY_NEURON</a>);</div>
<div class="line">sim.<a class="code" href="classCARLsim.html#aa6e1dc5ae50722ae3d693f2c963d84cd">setNeuronParameters</a>(gSmoothInh, 0.02f, 0.2f, -65.0f, 8.0f);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> gEdges = sim.<a class="code" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">createGroup</a>(<span class="stringliteral">&quot;edges&quot;</span>, imgSmallDim, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>);</div>
<div class="line">sim.<a class="code" href="classCARLsim.html#aa6e1dc5ae50722ae3d693f2c963d84cd">setNeuronParameters</a>(gEdges, 0.02f, 0.2f, -65.0f, 8.0f);</div>
</div><!-- fragment --><h2><a class="anchor" id="tut4s3s2_dog"></a>
4.3.2 Performing the Difference of Gaussians (DOG) Operation</h2>
<p>Setting up the connectivity is straightforward, too. The only annoying thing is that you will have to tune the synaptic weights in order to get this right.</p>
<p>Luckily I have already done this for you. We need two feedforward connections from the input group: One with a small kernel to an excitatory group, and another with a larger kernel to an inhibitory group. </p><div class="fragment"><div class="line">sim.<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(gIn, gSmoothExc, <span class="stringliteral">&quot;gaussian&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(10.0f), 1.0f,</div>
<div class="line">    <a class="code" href="structRangeDelay.html">RangeDelay</a>(1), <a class="code" href="structRadiusRF.html">RadiusRF</a>(0.5,0.5,-1));</div>
<div class="line"> </div>
<div class="line">sim.<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(gIn, gSmoothInh, <span class="stringliteral">&quot;gaussian&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(5.0f), 1.0f,</div>
<div class="line">    <a class="code" href="structRangeDelay.html">RangeDelay</a>(1), <a class="code" href="structRadiusRF.html">RadiusRF</a>(3,3,-1));</div>
</div><!-- fragment --><p>We then want to subtract the output of <code>gSmoothInh</code> from <code>gSmoothExc</code>: </p><div class="fragment"><div class="line">sim.<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(gSmoothExc, gEdges, <span class="stringliteral">&quot;one-to-one&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(16.0f), 1.0f,</div>
<div class="line">    <a class="code" href="structRangeDelay.html">RangeDelay</a>(1));</div>
<div class="line">sim.<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(gSmoothInh, gEdges, <span class="stringliteral">&quot;one-to-one&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(100.0f), 1.0f,</div>
<div class="line">    <a class="code" href="structRangeDelay.html">RangeDelay</a>(1));</div>
</div><!-- fragment --><h2><a class="anchor" id="tut4s3s3_converting"></a>
4.3.3 Converting Pixels to Spikes</h2>
<p>This time around, we want the input to be a little more exact than a Poisson rate. The problem with the Poisson distribution is that the actual firing rate you get from a specified mean firing rate lambda has variance equal to lambda!</p>
<p>A more exact translation would be to convert the grayscale value of a pixel to a constant inter-spike interval (ISI), so that the firing rate of the corresponding neuron is 1/ISI.</p>
<p>We do this by subclassing <a class="el" href="classSpikeGenerator.html">SpikeGenerator</a> and creating our own spike generator class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ConstantISI : <span class="keyword">public</span> <a class="code" href="classSpikeGenerator.html">SpikeGenerator</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ConstantISI(<span class="keywordtype">int</span> numNeur) {</div>
<div class="line">        _numNeur = numNeur;</div>
<div class="line">    }</div>
<div class="line">    ~ConstantISI() {}</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    <span class="keywordtype">int</span> _numNeur;</div>
<div class="line">    std::vector&lt;int&gt; _isi;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The class has a private integer <code>_numNeur</code> that holds the number of neurons in the group, and a vector <code>_isi</code> that holds the ISI for every neuron in the group.</p>
<p>We then need to specify a <code>nextSpikeTime</code> method. This method is supposed to return the next spike time of a specific neuron <code>nid</code> in the group <code>grpId</code>. In our case, the next spike time is simply: the last spike of the neuron plus its ISI: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextSpikeTime(<a class="code" href="classCARLsim.html">CARLsim</a>* sim, <span class="keywordtype">int</span> grpId, <span class="keywordtype">int</span> nid, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currentTime,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastScheduledSpikeTime, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> endOfTimeSlice)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// printf(&quot;_numNeur=%d, getGroupNumNeurons=%d\n&quot;,_numNeur, sim-&gt;getGroupNumNeurons(grpId));</span></div>
<div class="line">    assert(_numNeur == sim-&gt;<a class="code" href="classCARLsim.html#ad85b898d98abe24dcae4390f0fe61e84">getGroupNumNeurons</a>(grpId));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// periodic spiking according to ISI</span></div>
<div class="line">    <span class="keywordflow">return</span> (std::max(currentTime, lastScheduledSpikeTime) + _isi[nid]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>What's left is a method to update the ISI on the fly. Here we accept as input an array of grayscale values <code>stimGray</code>, which should have the same elements as the number of neurons in the group, and the upper and lower bounds of our firing rates. For every neuron in the group, we read the grayscale value of the corresponding pixel, convert it to a mean firing rate, and then invert the firing rate to get an ISI: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> updateISI(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* stimGray, <span class="keywordtype">float</span> maxRateHz=50.0f, <span class="keywordtype">float</span> minRateHz=0.0f) {</div>
<div class="line">    _isi.clear();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculate inter-spike interval (ISI) from firing rate</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;_numNeur; i++) {</div>
<div class="line">        <span class="comment">// convert grayscale value to firing rate</span></div>
<div class="line">        <span class="keywordtype">float</span> rateHz = (float)stimGray[i] / 255.0f * (maxRateHz - minRateHz) + minRateHz;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// invert firing rate to get inter-spike interval (ISI)</span></div>
<div class="line">        <span class="keywordtype">int</span> isi = (rateHz &gt; 0.0f) ? std::max(1, (<span class="keywordtype">int</span>)(1000 / rateHz)) : 1000000;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// add value to vector</span></div>
<div class="line">        _isi.push_back(isi);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Yes, we could have implemented a constant-firing-rate class instead. After all, firing rate is 1/ISI. However, going with the ISI has the advantage that we need not think about the division by zero, and we only have to deal with integers.</dd></dl>
<h2><a class="anchor" id="tut4s3s4"></a>
4.3.4 Running the Network</h2>
<p>With our <code>ConstantISI</code> class in hand, we can assign to the input group: </p><div class="fragment"><div class="line">ConstantISI constISI(imgDim.N);</div>
<div class="line">sim.<a class="code" href="classCARLsim.html#adc71069e71cd551526ddafb3d873d649">setSpikeGenerator</a>(gIn, &amp;constISI);</div>
</div><!-- fragment --><p>Then we can use the <code>readFrameChar</code> method of the <a class="el" href="classVisualStimulus.html" title="Class to integrate CARLsim with a stimulus created using VisualStimulus.m Version: 4/11/14 Author: Mi...">VisualStimulus</a> bindings to get access to the raw grayscale values, and pass these to the <code>updateISI</code> method we wrote above: </p><div class="fragment"><div class="line"><span class="comment">// ---------------- RUN STATE -------------------</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;stim.getLength(); i++) {</div>
<div class="line">    constISI.updateISI(stim.readFrameChar(), 50.0f, 0.0f);</div>
<div class="line">    sim.<a class="code" href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">runNetwork</a>(1,0); <span class="comment">// run the network</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="tut4s3s5_plotting"></a>
4.3.5 Visualizing the Output</h2>
<p>You can compile and run the above network as follows:</p>
<div class="fragment"><div class="line">$ make dog</div>
<div class="line">$ ./dog</div>
</div><!-- fragment --><p>The result can then be analyzed using the OAT. Visualizing network activity is easiest with the NetworkMonitor. Go back to the <code>scripts</code> folder in MATLAB, and run:</p>
<div class="fragment"><div class="line">&gt;&gt; demoDOG</div>
</div><!-- fragment --><div class="image">
<img src="4_carl_dog.jpg" alt=""/>
<div class="caption">
Edge detection with CARLsim</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="acarlsim__datastructures_8h_html_a625c4eced5cd956404990e73f3950258a0b5ee5e90bb225a562d92e4078ad9728"><div class="ttname"><a href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258a0b5ee5e90bb225a562d92e4078ad9728">GPU_MODE</a></div><div class="ttdeci">@ GPU_MODE</div><div class="ttdoc">model is run on GPU card(s)</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00115">carlsim_datastructures.h:115</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a0bf4d12b0b90740faf9a2f6a4add0351"><div class="ttname"><a href="classCARLsim.html#a0bf4d12b0b90740faf9a2f6a4add0351">CARLsim::createSpikeGeneratorGroup</a></div><div class="ttdeci">int createSpikeGeneratorGroup(const std::string &amp;grpName, int nNeur, int neurType, int preferredPartition=ANY, ComputingBackend preferredBackend=CPU_CORES)</div><div class="ttdoc">creates a spike generator group</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01779">carlsim.cpp:1779</a></div></div>
<div class="ttc" id="astructRangeWeight_html"><div class="ttname"><a href="structRangeWeight.html">RangeWeight</a></div><div class="ttdoc">a range struct for synaptic weight magnitudes</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00311">carlsim_datastructures.h:311</a></div></div>
<div class="ttc" id="aclassCARLsim_html_aafb2d44405c96aafe089f96ff867018d"><div class="ttname"><a href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">CARLsim::runNetwork</a></div><div class="ttdeci">int runNetwork(int nSec, int nMsec=0, bool printRunSummary=true)</div><div class="ttdoc">run the simulation for time=(nSec*seconds + nMsec*milliseconds)</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01909">carlsim.cpp:1909</a></div></div>
<div class="ttc" id="aclassVisualStimulus_html"><div class="ttname"><a href="classVisualStimulus.html">VisualStimulus</a></div><div class="ttdoc">Class to integrate CARLsim with a stimulus created using VisualStimulus.m Version: 4/11/14 Author: Mi...</div><div class="ttdef"><b>Definition:</b> <a href="visual__stimulus_8h_source.html#l00056">visual_stimulus.h:56</a></div></div>
<div class="ttc" id="aclassPoissonRate_html"><div class="ttname"><a href="classPoissonRate.html">PoissonRate</a></div><div class="ttdoc">Class for generating Poisson spike trains.</div><div class="ttdef"><b>Definition:</b> <a href="poisson__rate_8h_source.html#l00084">poisson_rate.h:84</a></div></div>
<div class="ttc" id="acarlsim__definitions_8h_html_a71b1b059a7ff0783d39e22b9b1028d90"><div class="ttname"><a href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a></div><div class="ttdeci">#define EXCITATORY_NEURON</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__definitions_8h_source.html#l00077">carlsim_definitions.h:76</a></div></div>
<div class="ttc" id="acarlsim__datastructures_8h_html_a3a04fc42e22f436d2b3809236cb6ec54ae2d30a195cee6b2961cc2c23ea4b520b"><div class="ttname"><a href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54ae2d30a195cee6b2961cc2c23ea4b520b">USER</a></div><div class="ttdeci">@ USER</div><div class="ttdoc">User mode, for experiment-oriented simulations.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00091">carlsim_datastructures.h:91</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a04f52d2840105c8ccacf8d378d1695cf"><div class="ttname"><a href="classCARLsim.html#a04f52d2840105c8ccacf8d378d1695cf">CARLsim::setSpikeRate</a></div><div class="ttdeci">void setSpikeRate(int grpId, PoissonRate *spikeRate, int refPeriod=1)</div><div class="ttdoc">Sets a spike rate.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01982">carlsim.cpp:1982</a></div></div>
<div class="ttc" id="aclassCARLsim_html_adc71069e71cd551526ddafb3d873d649"><div class="ttname"><a href="classCARLsim.html#adc71069e71cd551526ddafb3d873d649">CARLsim::setSpikeGenerator</a></div><div class="ttdeci">void setSpikeGenerator(int grpId, SpikeGenerator *spikeGenFunc)</div><div class="ttdoc">A SpikeCounter keeps track of the number of spikes per neuron in a group.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01967">carlsim.cpp:1967</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a6d6c298c788eeb7b18a19d82a77761b3"><div class="ttname"><a href="classCARLsim.html#a6d6c298c788eeb7b18a19d82a77761b3">CARLsim::setupNetwork</a></div><div class="ttdeci">void setupNetwork()</div><div class="ttdoc">build the network</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01914">carlsim.cpp:1914</a></div></div>
<div class="ttc" id="astructRangeDelay_html"><div class="ttname"><a href="structRangeDelay.html">RangeDelay</a></div><div class="ttdoc">a range struct for synaptic delays</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00278">carlsim_datastructures.h:278</a></div></div>
<div class="ttc" id="aclassCARLsim_html_aa6e1dc5ae50722ae3d693f2c963d84cd"><div class="ttname"><a href="classCARLsim.html#aa6e1dc5ae50722ae3d693f2c963d84cd">CARLsim::setNeuronParameters</a></div><div class="ttdeci">void setNeuronParameters(int grpId, float izh_a, float izh_a_sd, float izh_b, float izh_b_sd, float izh_c, float izh_c_sd, float izh_d, float izh_d_sd)</div><div class="ttdoc">Sets Izhikevich params a, b, c, and d with as mean +- standard deviation.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01815">carlsim.cpp:1815</a></div></div>
<div class="ttc" id="aclassCARLsim_html"><div class="ttname"><a href="classCARLsim.html">CARLsim</a></div><div class="ttdoc">CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8h_source.html#l00137">carlsim.h:137</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a30b16b93d57551dcde0559e8a4e98e27"><div class="ttname"><a href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">CARLsim::connect</a></div><div class="ttdeci">short int connect(int grpId1, int grpId2, const std::string &amp;connType, const RangeWeight &amp;wt, float connProb, const RangeDelay &amp;delay=RangeDelay(1), const RadiusRF &amp;radRF=RadiusRF(-1.0), bool synWtType=SYN_FIXED, float mulSynFast=1.0f, float mulSynSlow=1.0f)</div><div class="ttdoc">Connects a presynaptic to a postsynaptic group using fixed/plastic weights and a range of delay value...</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01739">carlsim.cpp:1739</a></div></div>
<div class="ttc" id="astructGrid3D_html"><div class="ttname"><a href="structGrid3D.html">Grid3D</a></div><div class="ttdoc">A struct to arrange neurons on a 3D grid (a primitive cubic Bravais lattice with cubic side length 1)</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00489">carlsim_datastructures.h:489</a></div></div>
<div class="ttc" id="aclassSpikeGenerator_html"><div class="ttname"><a href="classSpikeGenerator.html">SpikeGenerator</a></div><div class="ttdef"><b>Definition:</b> <a href="callback_8h_source.html#l00063">callback.h:63</a></div></div>
<div class="ttc" id="aclassCARLsim_html_ad85b898d98abe24dcae4390f0fe61e84"><div class="ttname"><a href="classCARLsim.html#ad85b898d98abe24dcae4390f0fe61e84">CARLsim::getGroupNumNeurons</a></div><div class="ttdeci">int getGroupNumNeurons(int grpId)</div><div class="ttdoc">returns the number of neurons of a group specified by grpId</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l02076">carlsim.cpp:2076</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a1e0b4d170b65f5075f1a996554c842ab"><div class="ttname"><a href="classCARLsim.html#a1e0b4d170b65f5075f1a996554c842ab">CARLsim::setSpikeMonitor</a></div><div class="ttdeci">SpikeMonitor * setSpikeMonitor(int grpId, const std::string &amp;fileName)</div><div class="ttdoc">Sets a Spike Monitor for a groups, prints spikes to binary file.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01972">carlsim.cpp:1972</a></div></div>
<div class="ttc" id="acarlsim__definitions_8h_html_a1f1973192224715d2362de045a5c6387"><div class="ttname"><a href="carlsim__definitions_8h.html#a1f1973192224715d2362de045a5c6387">INHIBITORY_NEURON</a></div><div class="ttdeci">#define INHIBITORY_NEURON</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__definitions_8h_source.html#l00076">carlsim_definitions.h:75</a></div></div>
<div class="ttc" id="astructRadiusRF_html"><div class="ttname"><a href="structRadiusRF.html">RadiusRF</a></div><div class="ttdoc">A struct to specify the receptive field (RF) radius in 3 dimensions.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00363">carlsim_datastructures.h:363</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a6e11c10b6b079715074d857452c42e11"><div class="ttname"><a href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">CARLsim::createGroup</a></div><div class="ttdeci">int createGroup(const std::string &amp;grpName, int nNeur, int neurType, int preferredPartition=ANY, ComputingBackend preferredBackend=CPU_CORES)</div><div class="ttdoc">creates a group of Izhikevich spiking neurons</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01763">carlsim.cpp:1763</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jul 11 2020 19:24:13 for CARLsim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
