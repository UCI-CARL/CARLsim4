<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CARLsim: Chapter 12: Advanced Topics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="CARLsimStyles.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CARLsim
   &#160;<span id="projectnumber">4.1.0</span>
   </div>
   <div id="projectbrief">CARLsim: a GPU-accelerated SNN simulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ch12_advanced_topics.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Chapter 12: Advanced Topics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ch12s1_best_practices">12.1 Best Practices</a><ul><li class="level2"><a href="#ch12s1s1_tips_tricks">12.1.1 Tips and Tricks, Do&#39;s and Don&#39;ts</a></li>
<li class="level2"><a href="#ch12s1s2_speed_up">12.1.2 Ways to Speed Up Your Simulation</a></li>
</ul>
</li>
<li class="level1"><a href="#ch12s2_num_int">12.2 Numerical Integration Methods</a><ul><li class="level2"><a href="#ch12s2s1_euler">12.2.1 Euler Method</a></li>
<li class="level2"><a href="#ch12s2s2_RK4">12.2.2 Runge-Kutta Method</a></li>
</ul>
</li>
<li class="level1"><a href="#ch12s3_multi_gpu">12.3 Multi-GPU, multi-CPU, and hybrid simulation</a></li>
<li class="level1"><a href="#ch12s4_online_weight_tuning">12.4 On-Line Weight Tuning</a><ul><li class="level2"><a href="#ch12s4s1_simple_weight_tuner">12.4.1 Simple Weight Tuner</a></li>
<li class="level2"><a href="#ch12s4s2_set_weight">12.4.2 Setting the Weight of a Single Synapse</a></li>
<li class="level2"><a href="#ch12s4s3_bias_weights">12.4.3 Add a Bias to All the Weights of a Connection</a></li>
<li class="level2"><a href="#ch12s4s4_scale_weights">12.4.4 Scale All the Weigths of a Connection</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ch12s1_best_practices"></a>
12.1 Best Practices</h1>
<h2><a class="anchor" id="ch12s1s1_tips_tricks"></a>
12.1.1 Tips and Tricks, Do's and Don'ts</h2>
<p>SpikeMonitors and ConnectionMonitors, while very useful, can easily slow simulations down. They should be used for brief periods of time as opposed to the entire duration of the simulation. Additonally, it makes sense to target the exact group or connection you care about as opposed to all neurons or synapses in the simulation.</p>
<h2><a class="anchor" id="ch12s1s2_speed_up"></a>
12.1.2 Ways to Speed Up Your Simulation</h2>
<p>As mentioned above, leaving Spike or ConnectionMonitors on running for a long period of time or over a large group of neurons will slow the simulation down dramatically. Although many state variables are updated every timestep (ms), <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> performs more calculations as the number of spikes grow. Therefore simulations with high firing rates will necessarily slow the simulation down as well. A common trick to speed up simulations that have a training and testing phase is to train the <a class="el" href="classSNN.html" title="Contains all of CARLsim&#39;s core functionality.">SNN</a> and then output the network state (with synaptic weights) to preserve the training using saveSimulation. The network state can then be reloaded using loadSimulation. In this way, users can load a pre-trained network anytime they wish without incurring the cost of training.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ch7_monitoring.html#ch7s1_spike_monitor">7.1 Spike Monitor</a></dd></dl>
<h1><a class="anchor" id="ch12s2_num_int"></a>
12.2 Numerical Integration Methods</h1>
<p><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> currently supports forward-Euler and fourth-order Runge Kutta for the numerical integration of ODEs.</p>
<p>The integration method and integration time step can be specified via <a class="el" href="classCARLsim.html#a3c23ef1a19946fdd9c096367a45ac48e">CARLsim::setIntegrationMethod</a>. By default, the simulation uses forward-Euler with a basic integration step of 0.5ms.</p>
<p>The specified integration method will apply to all neurons in the network. Future <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> versions might allow to specify the integration method on a per-group basis.</p>
<p>In contrast to the <em>integration</em> time step, the <em>simulation</em> time step is always 1ms, meaning that spike times cannot be retrieved with sub-millisecond precision. Future <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> versions might allow for sub-millisecond spike times.</p>
<h2><a class="anchor" id="ch12s2s1_euler"></a>
12.2.1 Euler Method</h2>
<p>By default, <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> uses the forward (or standard) Euler method with an integration step of 0.5ms for numerical stability. This can be set explicitly with the following function call:</p>
<div class="fragment"><div class="line">sim.<a class="code" href="classCARLsim.html#a3c23ef1a19946fdd9c096367a45ac48e">setIntegrationMethod</a>(<a class="code" href="carlsim__datastructures_8h.html#a56814540c647b8b64abbc1655f2a7396a88052013bcaeb036f6fd739a56f4cccc">FORWARD_EULER</a>, numStepsPerMs);</div>
</div><!-- fragment --><p>where <code>numStepsPerMs</code> is the number of integration steps to perform per 1ms.</p>
<p>We suggest the number of time steps be at least 2 when working with the 4-parameter Izhikevich model (see <a class="el" href="ch3_neurons_synapses_groups.html#ch3s1s1_izhikevich_neurons4">3.1.1 Izhikevich Neurons (4-Parameter Model)</a>). We do not recommend to use forward-Euler when working with the 9-parameter Izhikevich or compartmental models (see <a class="el" href="ch3_neurons_synapses_groups.html#ch3s1s2_izhikevich_neurons9">3.1.2 Izhikevich Neurons (9-Parameter Model)</a> and <a class="el" href="ch3_neurons_synapses_groups.html#ch3s1s3_compartments">3.1.3 Multi-Compartment Neurons</a>).</p>
<dl class="section note"><dt>Note</dt><dd>The recovery variable of the Izhikevich model is always integrated using forward-Euler. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ch3_neurons_synapses_groups.html#ch3s1_neurons">3.1 Neurons</a> </dd>
<dd>
<a class="el" href="ch12_advanced_topics.html#ch12s2s2_RK4">12.2.2 Runge-Kutta Method</a></dd></dl>
<h2><a class="anchor" id="ch12s2s2_RK4"></a>
12.2.2 Runge-Kutta Method</h2>
<dl class="section author"><dt>Author</dt><dd>Stanislav Listopad </dd>
<dd>
Michael Beyeler</dd></dl>
<p><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> also supports the use of fourth-order Runge-Kutta (also referred to as "RK4", "classical Runge-Kutta method", or simply as "\em the Runge-Kutta method").</p>
<p>This can be specified with the following function call:</p>
<div class="fragment"><div class="line">sim.<a class="code" href="classCARLsim.html#a3c23ef1a19946fdd9c096367a45ac48e">setIntegrationMethod</a>(<a class="code" href="carlsim__datastructures_8h.html#a56814540c647b8b64abbc1655f2a7396af9f44d4e51190c156907b1a3c0c9a27b">RUNGE_KUTTA4</a>, numStepsPerMs);</div>
</div><!-- fragment --><p>where <code>numStepsPerMs</code> is the number of integration steps to perform per 1ms.</p>
<p>We suggest the number of time steps be at least 10 when working with compartmental neurons (see <a class="el" href="ch3_neurons_synapses_groups.html#ch3s1s3_compartments">3.1.3 Multi-Compartment Neurons</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Note that the higher numStepsPerMs the slower the simulation may be, due to increased computational load. </dd>
<dd>
The recovery variable of the Izhikevich model is always integrated using forward-Euler. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.1</dd></dl>
<h1><a class="anchor" id="ch12s3_multi_gpu"></a>
12.3 Multi-GPU, multi-CPU, and hybrid simulation</h1>
<dl class="section author"><dt>Author</dt><dd>Hirak J Kashyap</dd></dl>
<p><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> is now threadsafe so a distinct <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> simulation can be run on every GPU device and/or every CPU core on the machine. We call simulations using multiple GPUs as multi-GPU simulation, using multiple CPUs as multi-CPU simulation, and using multiple GPUs and CPUs as hybrid simulation. The user can easily control simulations on multiple CPU/GPU by specifying the preferred partition while creating each group. Currently, upto 8 GPUs and 24 CPU cores can be used concurrently in a single simulation. The available processors are indexed from 0. By default, CARLsim4 places all the neuron groups on CPU 0 partition. The following examples show how to specify the preferred processor for each neuron group</p>
<p>For example, to create a group of Izhikevich neurons on a GPU partition using <a class="el" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11" title="creates a group of Izhikevich spiking neurons">CARLsim::createGroup</a>, simply specify a name (e.g., "exc1"), the number of neurons (e.g., 100), a type (e.g. EXCITATORY_NEURON), the preferred parition number (0-7 for GPU, must be less than or equal to available GPUs), and the computing backend (CPU_CORES/GPU_CORES): </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> gExc1 = sim.<a class="code" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">createGroup</a>(<span class="stringliteral">&quot;exc1&quot;</span>, 100, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>,1,<a class="code" href="carlsim__datastructures_8h.html#abd8abb75fc2813034b9ec6106ac26935ad01a1b87aa096199926c388985870bc3">GPU_CORES</a>);</div>
</div><!-- fragment --><p>To create a group of spike generators on GPU 0, the user also specifies a name, size, type, the preferred parition number, and the computing backend: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> gIn = sim.<a class="code" href="classCARLsim.html#a0bf4d12b0b90740faf9a2f6a4add0351">createSpikeGeneratorGroup</a>(<span class="stringliteral">&quot;input&quot;</span>, 10, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>, 0, <a class="code" href="carlsim__datastructures_8h.html#abd8abb75fc2813034b9ec6106ac26935ad01a1b87aa096199926c388985870bc3">GPU_CORES</a>);</div>
</div><!-- fragment --><p>Similarly, the following method call creates a LIF neuron group named "inh1" and places it on CPU 3 partition.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> gInh1 = sim.<a class="code" href="classCARLsim.html#a723d7b7887644e2444c980a5834414e3">createGroupLIF</a>(<span class="stringliteral">&quot;inh1&quot;</span>, 2018, <a class="code" href="carlsim__definitions_8h.html#a1f1973192224715d2362de045a5c6387">INHIBITORY_NEURON</a>, 3, <a class="code" href="carlsim__datastructures_8h.html#abd8abb75fc2813034b9ec6106ac26935abb15133ac8fa07c26855e6062b5ce9c1">CPU_CORES</a>);</div>
</div><!-- fragment --><p>An example CARLsim4 simulation using heterogeneous processors (CPU and GPU) and heterogeneous neurons (Izhikevich and LIF) is shown in the lif_izhi_random_spnet project under the projects/ directory. The example implements the clasic Izhikevich 80-20 network using LIF neurons and fast spiking Izhikevich neurons.</p>
<h1><a class="anchor" id="ch12s4_online_weight_tuning"></a>
12.4 On-Line Weight Tuning</h1>
<dl class="section author"><dt>Author</dt><dd>Michael Beyeler</dd></dl>
<p><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> provides a range of handy functions to change weight values on the fly; that is, without having to recompile the network. The utility <a class="el" href="classSimpleWeightTuner.html" title="Class SimpleWeightTuner.">SimpleWeightTuner</a> implements a simple weight search algorithm inspired by the bisection method. The function <a class="el" href="classCARLsim.html#af67a432c859556cff7d6b1d59638ad01" title="Sets the weight value of a specific synapse.">CARLsim::setWeight</a> allows a user to change the weight of a single synapse. Alternatively, <a class="el" href="classCARLsim.html#a075514437469255e73d058ce7a31092b" title="Adds a constant bias to the weight of every synapse in the connection.">CARLsim::biasWeights</a> can be used to add a constant bias to every weight of a certain connection ID, and <a class="el" href="classCARLsim.html#a1233e96d5b75c1de533375d52ee18869" title="reset Spike Counter to zero">CARLsim::scaleWeights</a> multiplies all the weights with a scaling factor.</p>
<p>These functions are useful especially for tuning feedforward weights in large-scale networks that would otherwise take a lot of time to repeatedly build. For tuning in more complex situations please refer to <a class="el" href="ch10_ecj.html">Chapter 10: ECJ</a>.</p>
<p>These functions are only valid in ::carlsimState_t <a class="el" href="carlsim__datastructures_8h.html#a8d0d24f2706656b1102c5e3624df65b2a67606f8f4ae6a12252ebcf0ddc2cc652" title="run state, where the model is stepped">RUN_STATE</a> and do not alter the topography of the network. They apply to weight values of already allocated synapses only.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ch10_ecj.html">Chapter 10: ECJ</a></dd></dl>
<h2><a class="anchor" id="ch12s4s1_simple_weight_tuner"></a>
12.4.1 Simple Weight Tuner</h2>
<p>The <a class="el" href="classSimpleWeightTuner.html" title="Class SimpleWeightTuner.">SimpleWeightTuner</a> utility is a class that allows tuning of weight values of a specific connection (i.e., a collection of synapses), so that a specific neuron group fires at a predefined target firing rate&mdash;without having to recompile the <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> network.</p>
<p>A complete example is explained in tut4_simple_weight_tuner.</p>
<p>Consider a <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> network with an input group (<code>gIn</code>) connected to an output group (<code>gOut</code>). Suppose the goal is to find weight values that lead to some desired output activity (say, 27.4Hz), in response to some Poissonian input. A conventional approach to solving this problem would be to repeatedly build and run the network with different weight values, until some values are found that let <code>gOut</code> approach the desired target firing rate. This process can be tedious, especially when dealing with large-scale networks that take a long time to build.</p>
<p>Instead, one can use a <a class="el" href="classSimpleWeightTuner.html" title="Class SimpleWeightTuner.">SimpleWeightTuner</a>: </p><div class="fragment"><div class="line"><a class="code" href="classSimpleWeightTuner.html">SimpleWeightTuner</a> SWT(sim, 0.01, 100); <span class="comment">// CARLsim object, error margin, max iterations</span></div>
<div class="line">SWT.setConnectionToTune(c0, 0.0);      <span class="comment">// connection to tune, initial weight</span></div>
<div class="line">SWT.setTargetFiringRate(gOut, 27.4);   <span class="comment">// output group to observe, target firing rate (Hz)</span></div>
</div><!-- fragment --><p> The <a class="el" href="classSimpleWeightTuner.html" title="Class SimpleWeightTuner.">SimpleWeightTuner</a> constructor accepts a pointer to the above created network <code>sim</code> and some termination conditions: The algorithm will terminate if either the absolute error between observed firing rate and target firing rate is smaller than some error margin, or upon reaching the maximum number of iterations. Calling <a class="el" href="classSimpleWeightTuner.html#a38404b885b5978e42b10f309a2e23c94" title="Sets up the connection to tune.">SimpleWeightTuner::setConnectionToTune</a> informs the class about which connection to tune and with which weight to start. The algorithm will repeatedly change the weights in a way that resembles the bisection method, until the mean firing rate of group <code>gOut</code> reaches 27.4 +- 0.01 Hz (specified via <a class="el" href="classSimpleWeightTuner.html#ac1c93ba1766ad5ada73dea7ba499d541" title="Sets up the target firing rate of a specific group.">SimpleWeightTuner::setTargetFiringRate</a>). Note that the here involved connection (<code>c0</code>) and neuron group (<code>gOut</code>) can be completely independent from each other.</p>
<p>All that is left to do is to execute the algorithm until finished: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (!SWT.done()) {</div>
<div class="line">    SWT.iterate();</div>
<div class="line">}</div>
</div><!-- fragment --><p> This will run <code>sim</code> repeatedly for one second (for different time periods pass an optional argument) until one of the termination criteria is reached.</p>
<dl class="section note"><dt>Note</dt><dd>The connection to tune and the neuron group for which a target firing rate are found do not have to be associated with each other. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ch10_ecj.html">Chapter 10: ECJ</a> </dd>
<dd>
tut4_simple_weight_tuner </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h2><a class="anchor" id="ch12s4s2_set_weight"></a>
12.4.2 Setting the Weight of a Single Synapse</h2>
<p>The easiest way to change the weight of a synapse is <a class="el" href="classCARLsim.html#af67a432c859556cff7d6b1d59638ad01" title="Sets the weight value of a specific synapse.">CARLsim::setWeight</a>: </p><div class="fragment"><div class="line"><span class="comment">// must be in RUN state</span></div>
<div class="line">sim.<a class="code" href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">runNetwork</a>(1,0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remember connId from connect call</span></div>
<div class="line"><span class="comment">// change the weight from first pre-neuron to fifth post-neuron to 0.25f</span></div>
<div class="line"><span class="comment">// make sure this synapse this allocated!</span></div>
<div class="line">sim.<a class="code" href="classCARLsim.html#af67a432c859556cff7d6b1d59638ad01">setWeight</a>(connId, 0, 4, 0.25f);</div>
</div><!-- fragment --><p> This function will set the weight of a particular synapse of connection ID <code>connId</code>, namely the synapse connecting neuron <code>neurIdPre</code> to neuron <code>neurIdPost</code>, to value <code>weight</code>. Here, the connection ID is the return argument of the corresponding <a class="el" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27" title="Connects a presynaptic to a postsynaptic group using fixed/plastic weights and a range of delay value...">CARLsim::connect</a> call. Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.</p>
<p>If the specified weight lies outside the boundaries <code>[minWt,maxWt]</code> of <a class="el" href="structRangeWeight.html" title="a range struct for synaptic weight magnitudes">RangeWeight</a>, then two different behaviors can be achieved, depending on a fifth optional argument <code>updateWeightRange</code>.</p><ul>
<li>If <code>updateWeightRange</code> is set to <code>true</code>, then the corresponding weight boundaries <code>[minWt,maxWt]</code> will be updated should the specified weight lie outside those boundaries.</li>
<li>If <code>updateWeightRange</code> is set to <code>false</code>, then the corresponding weight will be clipped so that it stays within the existing weight boundaries <code>[minWt,maxWt]</code>.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Make sure this function is called on a synapse that actually exists! </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h2><a class="anchor" id="ch12s4s3_bias_weights"></a>
12.4.3 Add a Bias to All the Weights of a Connection</h2>
<p>Alternatively, it is possible to change the weights of all the synapses that belong to a certain connection ID using <a class="el" href="classCARLsim.html#a075514437469255e73d058ce7a31092b" title="Adds a constant bias to the weight of every synapse in the connection.">CARLsim::biasWeights</a>: </p><div class="fragment"><div class="line"><span class="comment">// must be in RUN state</span></div>
<div class="line">sim.<a class="code" href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">runNetwork</a>(1,0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remember connId from connect call</span></div>
<div class="line"><span class="comment">// add 0.125 to all allocated synapses of connId</span></div>
<div class="line"><span class="comment">// set updateWeightRange flag to true in order to update [minWt,maxWt] if necessary</span></div>
<div class="line">sim.<a class="code" href="classCARLsim.html#a075514437469255e73d058ce7a31092b">biasWeights</a>(connId, 0.125f, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p> This function will add a constant <code>bias</code> to the weight of every synapse of connection ID <code>connId</code>. Here, the connection ID is the return argument of the corresponding <a class="el" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27" title="Connects a presynaptic to a postsynaptic group using fixed/plastic weights and a range of delay value...">CARLsim::connect</a> call. Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.</p>
<p>If the new weight (old weight plus bias) lies outside the boundaries <code>[minWt,maxWt]</code> of <a class="el" href="structRangeWeight.html" title="a range struct for synaptic weight magnitudes">RangeWeight</a>, then two different behaviors can be achieved, depending on a third optional argument <code>updateWeightRange</code>.</p><ul>
<li>If <code>updateWeightRange</code> is set to <code>true</code>, then the corresponding weight boundaries <code>[minWt,maxWt]</code> will be updated should the new weight lie outside those boundaries.</li>
<li>If <code>updateWeightRange</code> is set to <code>false</code>, then the corresponding weight will be clipped so that it stays within the existing weight boundaries <code>[minWt,maxWt]</code>.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h2><a class="anchor" id="ch12s4s4_scale_weights"></a>
12.4.4 Scale All the Weigths of a Connection</h2>
<p>Alternatively, it is possible to change the weights of all the synapses that belong to a certain connection ID using <a class="el" href="classCARLsim.html#a1233e96d5b75c1de533375d52ee18869" title="reset Spike Counter to zero">CARLsim::scaleWeights</a>: </p><div class="fragment"><div class="line"><span class="comment">// must be in RUN state</span></div>
<div class="line">sim.<a class="code" href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">runNetwork</a>(1,0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remember connId from connect call</span></div>
<div class="line"><span class="comment">// multiply all allocated synapses of connId with scaling factor 1.345</span></div>
<div class="line"><span class="comment">// set updateWeightRange flag to true because it will be necessary to update [minWt,maxWt]</span></div>
<div class="line">sim.<a class="code" href="classCARLsim.html#a1233e96d5b75c1de533375d52ee18869">scaleWeights</a>(connId, 1.345f, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p> This function will multiply the weight of every synapse of connection ID <code>connId</code> with a scaling factor <code>scale</code>. Here, the connection ID is the return argument of the corresponding <a class="el" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27" title="Connects a presynaptic to a postsynaptic group using fixed/plastic weights and a range of delay value...">CARLsim::connect</a> call. Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.</p>
<p>If the new weight (old weight times scaling factor) lies outside the boundaries <code>[minWt,maxWt]</code> of <a class="el" href="structRangeWeight.html" title="a range struct for synaptic weight magnitudes">RangeWeight</a>, then two different behaviors can be achieved, depending on a third optional argument <code>updateWeightRange</code>.</p><ul>
<li>If <code>updateWeightRange</code> is set to <code>true</code>, then the corresponding weight boundaries <code>[minWt,maxWt]</code> will be updated should the new weight lie outside those boundaries.</li>
<li>If <code>updateWeightRange</code> is set to <code>false</code>, then the corresponding weight will be clipped so that it stays within the existing weight boundaries <code>[minWt,maxWt]</code>.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassCARLsim_html_a0bf4d12b0b90740faf9a2f6a4add0351"><div class="ttname"><a href="classCARLsim.html#a0bf4d12b0b90740faf9a2f6a4add0351">CARLsim::createSpikeGeneratorGroup</a></div><div class="ttdeci">int createSpikeGeneratorGroup(const std::string &amp;grpName, int nNeur, int neurType, int preferredPartition=ANY, ComputingBackend preferredBackend=CPU_CORES)</div><div class="ttdoc">creates a spike generator group</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01779">carlsim.cpp:1779</a></div></div>
<div class="ttc" id="aclassSimpleWeightTuner_html"><div class="ttname"><a href="classSimpleWeightTuner.html">SimpleWeightTuner</a></div><div class="ttdoc">Class SimpleWeightTuner.</div><div class="ttdef"><b>Definition:</b> <a href="simple__weight__tuner_8h_source.html#l00088">simple_weight_tuner.h:88</a></div></div>
<div class="ttc" id="aclassCARLsim_html_aafb2d44405c96aafe089f96ff867018d"><div class="ttname"><a href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">CARLsim::runNetwork</a></div><div class="ttdeci">int runNetwork(int nSec, int nMsec=0, bool printRunSummary=true)</div><div class="ttdoc">run the simulation for time=(nSec*seconds + nMsec*milliseconds)</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01909">carlsim.cpp:1909</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a075514437469255e73d058ce7a31092b"><div class="ttname"><a href="classCARLsim.html#a075514437469255e73d058ce7a31092b">CARLsim::biasWeights</a></div><div class="ttdeci">void biasWeights(short int connId, float bias, bool updateWeightRange=false)</div><div class="ttdoc">Adds a constant bias to the weight of every synapse in the connection.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01936">carlsim.cpp:1936</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a1233e96d5b75c1de533375d52ee18869"><div class="ttname"><a href="classCARLsim.html#a1233e96d5b75c1de533375d52ee18869">CARLsim::scaleWeights</a></div><div class="ttdeci">void scaleWeights(short int connId, float scale, bool updateWeightRange=false)</div><div class="ttdoc">reset Spike Counter to zero</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01944">carlsim.cpp:1944</a></div></div>
<div class="ttc" id="acarlsim__definitions_8h_html_a71b1b059a7ff0783d39e22b9b1028d90"><div class="ttname"><a href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a></div><div class="ttdeci">#define EXCITATORY_NEURON</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__definitions_8h_source.html#l00077">carlsim_definitions.h:76</a></div></div>
<div class="ttc" id="acarlsim__datastructures_8h_html_a56814540c647b8b64abbc1655f2a7396af9f44d4e51190c156907b1a3c0c9a27b"><div class="ttname"><a href="carlsim__datastructures_8h.html#a56814540c647b8b64abbc1655f2a7396af9f44d4e51190c156907b1a3c0c9a27b">RUNGE_KUTTA4</a></div><div class="ttdeci">@ RUNGE_KUTTA4</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00134">carlsim_datastructures.h:134</a></div></div>
<div class="ttc" id="aclassCARLsim_html_af67a432c859556cff7d6b1d59638ad01"><div class="ttname"><a href="classCARLsim.html#af67a432c859556cff7d6b1d59638ad01">CARLsim::setWeight</a></div><div class="ttdeci">void setWeight(short int connId, int neurIdPre, int neurIdPost, float weight, bool updateWeightRange=false)</div><div class="ttdoc">Sets the weight value of a specific synapse.</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01987">carlsim.cpp:1987</a></div></div>
<div class="ttc" id="acarlsim__datastructures_8h_html_a56814540c647b8b64abbc1655f2a7396a88052013bcaeb036f6fd739a56f4cccc"><div class="ttname"><a href="carlsim__datastructures_8h.html#a56814540c647b8b64abbc1655f2a7396a88052013bcaeb036f6fd739a56f4cccc">FORWARD_EULER</a></div><div class="ttdeci">@ FORWARD_EULER</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00133">carlsim_datastructures.h:133</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a3c23ef1a19946fdd9c096367a45ac48e"><div class="ttname"><a href="classCARLsim.html#a3c23ef1a19946fdd9c096367a45ac48e">CARLsim::setIntegrationMethod</a></div><div class="ttdeci">void setIntegrationMethod(integrationMethod_t method, int numStepsPerMs)</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01809">carlsim.cpp:1809</a></div></div>
<div class="ttc" id="acarlsim__datastructures_8h_html_abd8abb75fc2813034b9ec6106ac26935ad01a1b87aa096199926c388985870bc3"><div class="ttname"><a href="carlsim__datastructures_8h.html#abd8abb75fc2813034b9ec6106ac26935ad01a1b87aa096199926c388985870bc3">GPU_CORES</a></div><div class="ttdeci">@ GPU_CORES</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00150">carlsim_datastructures.h:149</a></div></div>
<div class="ttc" id="acarlsim__definitions_8h_html_a1f1973192224715d2362de045a5c6387"><div class="ttname"><a href="carlsim__definitions_8h.html#a1f1973192224715d2362de045a5c6387">INHIBITORY_NEURON</a></div><div class="ttdeci">#define INHIBITORY_NEURON</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__definitions_8h_source.html#l00076">carlsim_definitions.h:75</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a723d7b7887644e2444c980a5834414e3"><div class="ttname"><a href="classCARLsim.html#a723d7b7887644e2444c980a5834414e3">CARLsim::createGroupLIF</a></div><div class="ttdeci">int createGroupLIF(const std::string &amp;grpName, int nNeur, int neurType, int preferredPartition=ANY, ComputingBackend preferredBackend=CPU_CORES)</div><div class="ttdoc">creates a group of Leaky-Integrate-and-Fire (LIF) spiking neurons</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01771">carlsim.cpp:1771</a></div></div>
<div class="ttc" id="aclassCARLsim_html_a6e11c10b6b079715074d857452c42e11"><div class="ttname"><a href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">CARLsim::createGroup</a></div><div class="ttdeci">int createGroup(const std::string &amp;grpName, int nNeur, int neurType, int preferredPartition=ANY, ComputingBackend preferredBackend=CPU_CORES)</div><div class="ttdoc">creates a group of Izhikevich spiking neurons</div><div class="ttdef"><b>Definition:</b> <a href="carlsim_8cpp_source.html#l01763">carlsim.cpp:1763</a></div></div>
<div class="ttc" id="acarlsim__datastructures_8h_html_abd8abb75fc2813034b9ec6106ac26935abb15133ac8fa07c26855e6062b5ce9c1"><div class="ttname"><a href="carlsim__datastructures_8h.html#abd8abb75fc2813034b9ec6106ac26935abb15133ac8fa07c26855e6062b5ce9c1">CPU_CORES</a></div><div class="ttdeci">@ CPU_CORES</div><div class="ttdef"><b>Definition:</b> <a href="carlsim__datastructures_8h_source.html#l00148">carlsim_datastructures.h:148</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jul 11 2020 19:24:13 for CARLsim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
